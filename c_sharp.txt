using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections.Concurrent;

namespace BlockSolve
{

    class Set_info
    {
        public HashSet<uint> chemical_set = new HashSet<uint>();
        public HashSet<uint> protein_set = new HashSet<uint>();
        public uint block_size = 0;
    }
   
    class Program
    {
        static Dictionary<uint, HashSet<uint>> main_map = new Dictionary<uint, HashSet<uint>>();        
        static ConcurrentDictionary<String, Set_info> all_sets = new ConcurrentDictionary<String, Set_info>();

        static void Main(string[] args)
        {
            load_input();

            int skip = 0;

            //foreach (KeyValuePair<uint, HashSet<uint>> a_kvp in main_map)
            //{
                Parallel.ForEach(main_map, a_kvp =>
                {
                    skip += 1;

                    foreach (KeyValuePair<uint, HashSet<uint>> b_kvp in main_map.Skip(skip))
                    {
                        HashSet<uint> a_v = new HashSet<uint>(a_kvp.Value);
                        a_v.IntersectWith(b_kvp.Value);

                        if (a_v.Count > 1)
                        {
                            // Made a block
                            Set_info set_info = new Set_info();

                            string key = string.Join(" ", a_v);
                            if (all_sets.ContainsKey(key))
                            {
                                all_sets.TryGetValue(key, out set_info);
                                set_info.protein_set.Add(a_kvp.Key);
                                set_info.protein_set.Add(b_kvp.Key);
                            }
                            else
                            {
                                set_info.chemical_set = a_v;
                                set_info.protein_set.Add(a_kvp.Key);
                                set_info.protein_set.Add(b_kvp.Key);
                                all_sets.TryAdd(key, set_info);
                            }
                              
                            //Console.WriteLine("set [" +key +"]" + " proteins [" + a_kvp.Key + " " + b_kvp.Key + "]");
                        }
                    }
                    }); 
                //}
            //}                     

            //Round 2. Assign any left out subsets         
            //foreach (KeyValuePair<String, Set_info> a_kvp in all_sets)
            Parallel.ForEach(all_sets, a_kvp =>
            {
                int a_len = a_kvp.Value.chemical_set.Count;

                foreach (KeyValuePair<String, Set_info> b_kvp in all_sets)
                {
                    // The A chem set should be less in length than the B chem set for the possibility of a subset
                    if (a_len < b_kvp.Value.chemical_set.Count && a_kvp.Value.chemical_set.IsSubsetOf(b_kvp.Value.chemical_set))
                    {
                        // Make sure all the proteins of the superset are also in the subset
                        a_kvp.Value.protein_set.UnionWith(b_kvp.Value.protein_set);
                    }
                }
             });

            int block_size = 0;
            foreach (var item in all_sets.OrderBy(x=> x.Value.chemical_set.Count * x.Value.protein_set.Count))
            {
                //Weird occurence where there are "0" items as proteins
                item.Value.protein_set.RemoveWhere(x => x < 1);

                if (block_size != item.Value.protein_set.Count * item.Value.chemical_set.Count)
                {
                    Console.WriteLine("\n Block Size " + item.Value.protein_set.Count * item.Value.chemical_set.Count);
                    block_size = item.Value.protein_set.Count * item.Value.chemical_set.Count;
                }


                Console.WriteLine("C[" + item.Key + "] P[" + string.Join(" ", item.Value.protein_set.OrderBy(x => x)) + "]");
            }
            
        }

                
        static void load_input(){        
            string[] lines = System.IO.File.ReadAllLines(@"input.txt");

            foreach (string line in lines)
            {
                //Console.WriteLine("\t" + line);
                string[] split = line.Split(',');

                uint protein = uint.Parse(split[0]);
                HashSet<uint> c_set = new HashSet<uint>();
                                

                foreach (string s in split.Skip(1)){
                    c_set.Add(uint.Parse(s));
                }

                main_map.Add(protein, c_set);  
            } 
        }


      

    }
}
