using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BlockSolve
{

    class Set_info
    {
        public HashSet<uint> chemical_set = new HashSet<uint>();
        public HashSet<uint> protein_set = new HashSet<uint>();
    }
   
    class Program
    {
        static Dictionary<uint, HashSet<uint>> main_map = new Dictionary<uint, HashSet<uint>>();
        static Dictionary<String, Set_info> all_sets = new Dictionary<String, Set_info>();

        static void Main(string[] args)
        {
            load_input();

            int skip = 0;
      
            foreach (KeyValuePair<uint, HashSet<uint>> a_kvp in main_map)
            {
                skip += 1;

                foreach (KeyValuePair<uint, HashSet<uint>> b_kvp in main_map.Skip(skip))
                {
                    HashSet<uint> a_v = new HashSet<uint>(a_kvp.Value);
                    a_v.IntersectWith(b_kvp.Value);        
            
                    if (a_v.Count > 1)
                    {
                        // Made a block
                        Set_info set_info = new Set_info();

                        string key = string.Join(" ", a_v);                        
                        if (all_sets.ContainsKey(key))
                        {
                            all_sets.TryGetValue(key, out set_info);
                            set_info.protein_set.Add(a_kvp.Key);
                            set_info.protein_set.Add(b_kvp.Key);
                            continue;
                        }
                        set_info.chemical_set = a_v;
                        set_info.protein_set.Add(a_kvp.Key);
                        set_info.protein_set.Add(b_kvp.Key);
                        all_sets.Add(key,set_info);
                        

                        //Console.WriteLine("set [" +key +"]" + " proteins [" + a_kvp.Key + " " + b_kvp.Key + "]");
                    }
                }
            }     

            //foreach (var item in all_sets)
            //{
            //    Console.WriteLine("C["+item.Key + "] P[" + string.Join(" ",item.Value) + "]");
            //}


            //Round 2. Assign any left out subsets
            skip = 0;
            foreach (KeyValuePair<String, Set_info> a_kvp in all_sets)
            {
                int a_len = a_kvp.Value.chemical_set.Count;

                skip += 1;
                foreach (KeyValuePair<String, Set_info> b_kvp in all_sets.Skip(skip))
                {
                    // The A chem set should be less in length than the B chem set for the possibility of a subset
                    if (a_len < b_kvp.Value.chemical_set.Count && a_kvp.Value.chemical_set.IsSubsetOf(b_kvp.Value.chemical_set))
                    {
                        // Make sure all the proteins of the superset are also in the subset
                        a_kvp.Value.protein_set.UnionWith(b_kvp.Value.protein_set);
                    }                    
                }
            }

            foreach (var item in all_sets)
            {
                Console.WriteLine("C[" + item.Key + "] P[" + string.Join(" ", item.Value.protein_set) + "]");
            }


        }
        
        
        static void load_input(){        
            string[] lines = System.IO.File.ReadAllLines(@"input.txt");

            foreach (string line in lines)
            {
                //Console.WriteLine("\t" + line);
                string[] split = line.Split(',');

                uint protein = uint.Parse(split[0]);
                HashSet<uint> c_set = new HashSet<uint>();
                                

                foreach (string s in split.Skip(1)){
                    c_set.Add(uint.Parse(s));
                }

                main_map.Add(protein, c_set);  
            } 
        }


      

    }
}
